##题目：根据上述自己对于第一题和第二题的演示，写一段对于不同GC的总结，提交到github。
####常见各种垃圾回收器的设计原理表
                       串行             并行                      并发                   算法
    新生代垃圾收集器   Serial       ParaNew、Parallel Scavenge                            复制 
    老年代垃圾收集器   Serial Old      Parallel Old                CMS（标记清除）        标记整理
    都适用                                                        G1              标记整理+复制算法

####使用搭配
    1.Serial + Serial Old （串行（单线程）垃圾回收机制：是hotspot虚拟机运行在客户端模式下默认的收集器）
        优点：非常小的内存消耗，没有线程交互的开销，使其高效而简单。
        缺点：无法充分发挥多核cpu优势，大内存停顿时间较长。
        补充：Serial Old 也用于CMS发生失败时的备用预案。
        
    2.Parallel Scavenge + Parallel Old （并行（多线程）垃圾回收机制：Java8默认垃圾收集器）
        优点：利用多核 CPU 的优势，大幅降低 GC 暂停时间，提升吞吐量。
        缺点：随着内存的增大，在进行GC时暂停的时间也增大，延迟可能增高。
    
    2.ParaNew + CMS (并发垃圾回收机制，多线程垃圾回收的同时，进行业务处理，适用于低延迟系统)
        优点：不对老年代进行整理，在标记-清除阶段的大部分工作和业务程序一起并发执行，避免在老年代垃圾收集时出现长时间的卡顿，降低延迟。
        缺点：CMS在内存不足时进行的垃圾回收，在并发模式失败后，会退化到单线程模式。
        
    4.G1 （并发垃圾回收机制，多线程垃圾回收的同时进行业务处理，适用于低延迟系统，Java9之后默认的垃圾收集器，CMS的升级版)
        优点：不对老年代进行整理，在标记-清除阶段的大部分工作和业务程序一起并发执行，避免在老年代垃圾收集时出现长时间的卡顿，降低延迟。
        缺点：内存不足时进行的垃圾回收，在并发模式失败后，会退化到单线程模式。
    
    5.ZGC（并发垃圾回收机制，多线程垃圾回收的同时进行业务处理，适用于低延迟系统)
        通过着色指针和读屏障，实现几乎全部的并发执行，几毫秒级别的延迟，线性可扩展

        
####堆内存使用
    计算分配速率和回收速率
    1.分配速率较低 ~ 回收速率 -> 健康
    2.分配速率 持续大于 回收速率 -> OOM
        分配速率持续大于回收速率，可能表明分配的对象数远大于回收对象数，可能是代码自身的问题，也可能是堆内存远小于所需要的内存，需要大幅提高堆内存
    3.分配速率很高 ~ 回收速率 -> 亚健康
        分配速率很高但约等于回收速率，表明分配的对象可能未进入老年代，直接被回收了，因此当下一次使用该对象时还需要重新创建，可以考虑稍微加大堆内存容量 
    
    